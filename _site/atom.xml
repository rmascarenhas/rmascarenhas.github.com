<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
  <title>rmascarenhas.com</title>
  <link href="http://rmascarenhas.com/"/>
  <link type="application/atom+xml" rel="self" href="http://rmascarenhas.com/atom.xml"/>
  <updated>2012-03-23T14:44:05-03:00</updated>
  <id>http://rmascarenhas.com/</id>
  <author>
    <name>Renato Mascarenhas</name>
    <email>renato.mascosta@gmail.com</email>
  </author>

  
  <entry>
    <id>http://rmascarenhas.com/2012/03/23/exit-ruby-and-you</id>
    <link type="text/html" rel="alternate" href="http://rmascarenhas.com/2012/03/23/exit-ruby-and-you.html"/>
    <title>Exit, Ruby and You</title>
    <updated>2012-03-23T00:00:00-03:00</updated>
    <author>
      <name>Renato Mascarenhas</name>
      <uri>http://rmascarenhas.com/</uri>
    </author>
    <content type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;A lot is done by Ruby once your script terminates or once you call &lt;code&gt;exit&lt;/code&gt;.&lt;/em&gt;
&lt;em&gt;&lt;code&gt;at_exit&lt;/code&gt; hooks are evaluated, finalizers are run and even an exception might be thrown. Knowing
all of this can be useful when developing your next awesome Ruby application.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; lower-level details, if present, are valid for an UNIX-like operating system.&lt;/p&gt;

&lt;h2&gt;Process termination&lt;/h2&gt;

&lt;p&gt;To start off, let's talk a little about process termination. I won't go into a greater level of detail since this
is not the main topic here (better save it for another post.)&lt;/p&gt;

&lt;p&gt;Every process has a parent, which is usually the process that created it. This constitutes what
is called the &lt;strong&gt;process hierarchy&lt;/strong&gt; and can be visualized using the &lt;em&gt;pstree(1)&lt;/em&gt; command. Go and
try it right now to have a look at your process hierarchy.&lt;/p&gt;

&lt;p&gt;Associated with every process termination is an &lt;strong&gt;exit status&lt;/strong&gt;, used to indicate the parent process
whether or not it was a successful execution. Conventionally, an exit status of &lt;em&gt;0&lt;/em&gt; indicates success
while a non-zero value indicates an error or abnormal program termination.&lt;/p&gt;

&lt;h2&gt;Ruby&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In our context, &lt;em&gt;exit&lt;/em&gt; refers to &lt;em&gt;Kernel#exit&lt;/em&gt;, which is different from what is executed
if you are using &lt;a href=&quot;https://github.com/ruby/ruby/blob/trunk/lib/irb/context.rb#L264&quot;&gt;irb&lt;/a&gt; or
&lt;a href=&quot;https://github.com/pry/pry/blob/master/lib/pry/default_commands/navigating_pry.rb#L53&quot;&gt;pry&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In Ruby, it's pretty easy to exit when you reach an unrecoverable path in your script for example.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greater_than_zero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;error_message&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;You don't need to be in an error situation necessarily. This example, extracted from the
&lt;a href=&quot;http://ruby-doc.org/stdlib-1.9.3/libdoc/optparse/rdoc/OptionParser.html&quot;&gt;OptParser&lt;/a&gt; class documentation
shows a common usage:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;n&quot;&gt;opts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;-h&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;--help&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Show this message&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opts&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;Calling &lt;em&gt;exit&lt;/em&gt; with no argument makes process terminate with a success exit status. You can verify
that &lt;em&gt;exit&lt;/em&gt; terminates your process with the given status with the following:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ruby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;exit 42&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$?&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;Worth noting is the fact that Ruby also provides the &lt;em&gt;exit!&lt;/em&gt; method and, as with all methods with
a bang at the end, it should be used only when you know what you are doing. The difference between
&lt;em&gt;exit&lt;/em&gt; and &lt;em&gt;exit!&lt;/em&gt; is explained in the following sections.&lt;/p&gt;

&lt;h3&gt;Digging Deeper&lt;/h3&gt;

&lt;p&gt;Time to take a look at the implementation of the &lt;em&gt;exit&lt;/em&gt; method. In this post, I'm going to show you
only some MRI code but the interested reader can later peek at the Rubinius or JRuby code to see what
is going on there too.&lt;/p&gt;

&lt;p&gt;If we look at the &lt;a href=&quot;https://github.com/ruby/ruby/blob/trunk/process.c&quot;&gt;process.c&lt;/a&gt; file, we learn that
the &lt;em&gt;exit&lt;/em&gt; method is added to the &lt;em&gt;Kernel&lt;/em&gt; module invoking the &lt;em&gt;rb_f_exit&lt;/em&gt; function. Let's look at it&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;rb_f_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* some exit status logic */&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;rb_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Qnil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* not reached */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;The first lines of this function just assigns the appropriate value to the &lt;em&gt;istatus&lt;/em&gt; variable, according
to the argument passed (if any). Then, the function that actually exits is the &lt;em&gt;rb_exit&lt;/em&gt;, since the &lt;em&gt;return&lt;/em&gt;
statement is never reached. So off we go!&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;rb_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET_THREAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT2NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb_str_new2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;exit&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rb_exc_raise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rb_class_new_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb_eSystemExit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ruby_finalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;Now we start to see some interesting calls. First of all, there seems to be an exception being raised as
we can see by the call to &lt;em&gt;rb_exc_raise&lt;/em&gt;. Is that truth?&lt;/p&gt;

&lt;p&gt;To check if that exception is really raised, we will use the handy
&lt;a href=&quot;http://www.ruby-doc.org/core-1.9.3/Kernel.html#method-i-set_trace_func&quot;&gt;set_trace_func&lt;/a&gt; method, allowing us to see what is called
when we try to &lt;em&gt;exit&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;nb&quot;&gt;set_trace_func&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
         &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;%8s %s:%-2d %10s %8s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classname&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;If you run this script, you will have an output which is similar with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c-return test.rb:3  set_trace_func   Kernel
    line test.rb:5                     
  c-call test.rb:5        exit   Kernel
  c-call test.rb:5  initialize SystemExit
  c-call test.rb:5  initialize Exception
c-return test.rb:5  initialize Exception
c-return test.rb:5  initialize SystemExit
  c-call test.rb:5   exception Exception
c-return test.rb:5   exception Exception
  c-call test.rb:5   backtrace Exception
c-return test.rb:5   backtrace Exception
  c-call test.rb:5  set_backtrace Exception
c-return test.rb:5  set_backtrace Exception
   raise test.rb:5        exit   Kernel
c-return test.rb:5        exit   Kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! As we suspected, an exception is raised, and it is a &lt;em&gt;SystemExit&lt;/em&gt;. This allows us
to write some code to check if our program is terminating in a successful way:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;call_exit_or_not&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SystemExit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;log_unsuccessful_path&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;success?&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;If we have a method that might call &lt;em&gt;exit&lt;/em&gt;, like the &lt;em&gt;#parse&lt;/em&gt; method from &lt;em&gt;OptParser&lt;/em&gt; that
we mentioned before, the approach above might be useful.&lt;/p&gt;

&lt;p&gt;What is left is the &lt;em&gt;ruby_finalize&lt;/em&gt; function call, which is defined in the
&lt;a href=&quot;https://github.com/ruby/ruby/blob/ruby_1_9_3/eval.c&quot;&gt;eval.c&lt;/a&gt; file.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;ruby_finalize_0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PUSH_TAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXEC_TAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rb_trap_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;POP_TAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rb_exec_end_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rb_clear_trace_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;ruby_finalize_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ruby_sig_finalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GET_THREAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errinfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Qnil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rb_gc_call_finalizer_at_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;ruby_finalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ruby_finalize_0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ruby_finalize_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;A lot of new function calls! But I'll focus on just two of them. The &lt;em&gt;rb_exec_end_proc&lt;/em&gt;
executes all of the callbacks registered with the &lt;em&gt;at_exit&lt;/em&gt; method. And there is also
&lt;em&gt;rb_gc_call_finalizer_at_exit&lt;/em&gt;, which finalizes the garbage collector. I will now
briefly describe each of these operations in a higher level.&lt;/p&gt;

&lt;h3&gt;Exit hooks&lt;/h3&gt;

&lt;p&gt;C programmers might be used with the &lt;em&gt;atexit(3)&lt;/em&gt; function from &lt;em&gt;stdlib&lt;/em&gt;. The idea is the same
in Ruby. You register a block of code and then it will be called on normal process termination.
As with the C function, the execution order is the reverse order in which the registrations occurred.&lt;/p&gt;

&lt;h3&gt;Finalizers&lt;/h3&gt;

&lt;p&gt;Ruby supports the registration of finalizers associated with any object. This is done via the &lt;em&gt;define_finalizer&lt;/em&gt;
method in the &lt;a href=&quot;http://www.ruby-doc.org/core-1.9.3/ObjectSpace.html&quot;&gt;ObjectSpace&lt;/a&gt; module (you should take a look at
its documentation if you didn't know about it.) A finalizer is run after an object is garbage collected.&lt;/p&gt;

&lt;p&gt;Basically a finalizer would serve to the purpose of freeing resources associated with an object.
In practice, their use is not encouraged in the Ruby community. If you have an object that needs to free
some resources, then write a method to do so, or expect a block to be passed and deal
with your resources transparently.&lt;/p&gt;

&lt;h3&gt;exit bang!&lt;/h3&gt;

&lt;p&gt;Now that we saw what happens when the &lt;em&gt;exit&lt;/em&gt; method is called, let's investigate its meaner version:
&lt;em&gt;exit!&lt;/em&gt;. It should be pretty straightforward to spot the difference:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;rb_f_exit_bang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* exit status logic again */&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Qnil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* not reached */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;That's exactly what you thought: instead of a call to the &lt;em&gt;rb_exit&lt;/em&gt; function, we have a call
to the &lt;em&gt;_exit(1)&lt;/em&gt; system call. What it means is that registered &lt;em&gt;at_exit&lt;/em&gt; hooks will not be run,
and neither will your finalizers. The &lt;em&gt;_exit&lt;/em&gt; system call is &lt;a href=&quot;http://linux.die.net/man/2/_exit&quot;&gt;guaranteed to finish&lt;/a&gt;,
with no return value.&lt;/p&gt;

&lt;h2&gt;In the wild&lt;/h2&gt;

&lt;p&gt;To finish off, let's take a look at an interesting piece of code from &lt;a href=&quot;https://github.com/seattlerb/minitest&quot;&gt;minitest&lt;/a&gt;,
since it demonstrates a useful way to use &lt;em&gt;at_exit&lt;/em&gt; handlers. Here it is:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;autorun&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;at_exit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$!&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;

        &lt;span class=&quot;nb&quot;&gt;at_exit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MiniTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;vc&quot;&gt;@@installed_at_exit&lt;/span&gt;
      &lt;span class=&quot;vc&quot;&gt;@@installed_at_exit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;If you ever wondered how your tests are run in a script that just defined a class that inherited from &lt;em&gt;MiniTest::Unit::TestCase&lt;/em&gt;,
here is how. In minitest, if you require &lt;em&gt;minitest/autorun&lt;/em&gt;, the above method is executed, causing an &lt;em&gt;at_exit&lt;/em&gt; handler to
be registered to run your tests. Minitest is even nice enough to make sure it returns a non-zero exit status (&lt;em&gt;EXIT_FAILURE&lt;/em&gt;)
if your tests fail. This allows you to write a shell script that sends an email to your boss when your tests pass, for example.&lt;/p&gt;

&lt;p&gt;Also interesting is the fact that you can use &lt;em&gt;next&lt;/em&gt; in an &lt;em&gt;at_exit&lt;/em&gt; handler, causing the next registered handler to be executed,
as if you were in an iteration. Sweet.&lt;/p&gt;

&lt;h2&gt;Tricky parts&lt;/h2&gt;

&lt;p&gt;Let's take minitest as an example again. If you have some code you wish to execute after your tests are run, you can do that
using the &lt;em&gt;MiniTest::Unit.after_tests&lt;/em&gt; method. You pass it a block and it is saved for later execution.&lt;/p&gt;

&lt;p&gt;Presumably, this was implemented using an &lt;em&gt;at_exit&lt;/em&gt; call with &lt;em&gt;yield&lt;/em&gt;. However, what would happen if you had the following code:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;minitest/autorun&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# pretend to have long tests so that we can check Twitter&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;MiniTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;after_tests&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Calculating...&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MiniTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;TestCase&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;You probably know where I'm trying to get: remember that when you require &lt;em&gt;minitest/autorun&lt;/em&gt; a new &lt;em&gt;at_exit&lt;/em&gt; handler
is registered. The same used to happen when you called &lt;em&gt;MiniTest::Unit.after_tests&lt;/em&gt;. Because the handlers are run
in reverse order of registration, the code in the &lt;em&gt;after_tests&lt;/em&gt; would be executed &lt;strong&gt;before&lt;/strong&gt; your tests are run. That
might not be what you expected.&lt;/p&gt;

&lt;p&gt;That's how the current implementation works:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;after_tests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;
      &lt;span class=&quot;vc&quot;&gt;@@after_tests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;autorun&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;at_exit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$!&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;

        &lt;span class=&quot;nb&quot;&gt;at_exit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;vc&quot;&gt;@@after_tests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;exit_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MiniTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;vc&quot;&gt;@@installed_at_exit&lt;/span&gt;
      &lt;span class=&quot;vc&quot;&gt;@@installed_at_exit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;No more &lt;em&gt;at_exit&lt;/em&gt; in the &lt;em&gt;after_tests&lt;/em&gt; method! Instead, the blocks are stored for later execution, imediately
after the tests are run. Now you can use the &lt;em&gt;after_tests&lt;/em&gt; method before or after you require &lt;em&gt;minitest/autorun&lt;/em&gt;
and be sure that it will be executed only after your tests.&lt;/p&gt;

&lt;p&gt;The last tricky fact to be aware of regards the &lt;em&gt;SystemExit&lt;/em&gt; exception which is raised when you call &lt;em&gt;exit&lt;/em&gt;. Let's
look at a small piece of code, this time from &lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;rake&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;standard_exception_handling&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SystemExit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;OptionParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;InvalidOption&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;
        &lt;span class=&quot;vg&quot;&gt;$stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;display_error_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;This exception handling method tries to rescue different types of exceptions and take the appropriate action.
What is interesting here is the fact that when a &lt;em&gt;SystemExit&lt;/em&gt; is rescued, just a call to &lt;em&gt;raise&lt;/em&gt; is done. The
&lt;em&gt;raise&lt;/em&gt; method, when called with no arguments, raises the content of the &lt;em&gt;$!&lt;/em&gt; variable (which holds the last exception
raised) or &lt;em&gt;RuntimeError&lt;/em&gt; if it is &lt;em&gt;nil&lt;/em&gt;. So in fact, it is ignored, allowing normal process termination. This is done
because later, &lt;em&gt;Exception&lt;/em&gt; is rescued and every exception in Ruby - including &lt;em&gt;SystemExit&lt;/em&gt; - inherits from &lt;em&gt;Exception&lt;/em&gt;.
So, if we had something like:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;      &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;display_error_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;we would call &lt;em&gt;display_error_message&lt;/em&gt; and &lt;em&gt;exit(false)&lt;/em&gt; if we made a call to &lt;em&gt;exit(true)&lt;/em&gt; in the block passed to this method,
for example, which is probably not what we want.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you are still reading, thanks! I didn't expect this to be such a long post. I'll try to make shorter ones next time.&lt;/p&gt;

&lt;p&gt;What is important to keep in mind from this, though, is what is done by Ruby on process termination. Being aware of
the order in which the &lt;em&gt;at_exit&lt;/em&gt; handlers are executed is very important to avoid unexpected results. Also important
is knowing about the &lt;em&gt;SystemExit&lt;/em&gt; exception and how you can inadvertently execute some code if you just rescue &lt;em&gt;Exception&lt;/em&gt;
without any further check.&lt;/p&gt;
</content>
  </entry>
  
 
</feed>
